{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nvar _excluded = [\"name\"];\nimport warning from \"rc-util/es/warning\";\nimport * as React from 'react';\nimport { HOOK_MARK } from './FieldContext';\nimport { allPromiseFinish } from './utils/asyncUtil';\nimport { merge } from \"rc-util/es/utils/set\";\nimport { defaultValidateMessages } from './utils/messages';\nimport NameMap from './utils/NameMap';\nimport { cloneByNamePathList, containsNamePath, getNamePath, getValue, matchNamePath, setValue } from './utils/valueUtil';\nexport var FormStore = /*#__PURE__*/_createClass(function FormStore(forceRootUpdate) {\n  var _this = this;\n  _classCallCheck(this, FormStore);\n  this.formHooked = false;\n  this.forceRootUpdate = void 0;\n  this.subscribable = true;\n  this.store = {};\n  this.fieldEntities = [];\n  this.initialValues = {};\n  this.callbacks = {};\n  this.validateMessages = null;\n  this.preserve = null;\n  this.lastValidatePromise = null;\n  this.getForm = function () {\n    return {\n      getFieldValue: _this.getFieldValue,\n      getFieldsValue: _this.getFieldsValue,\n      getFieldError: _this.getFieldError,\n      getFieldWarning: _this.getFieldWarning,\n      getFieldsError: _this.getFieldsError,\n      isFieldsTouched: _this.isFieldsTouched,\n      isFieldTouched: _this.isFieldTouched,\n      isFieldValidating: _this.isFieldValidating,\n      isFieldsValidating: _this.isFieldsValidating,\n      resetFields: _this.resetFields,\n      setFields: _this.setFields,\n      setFieldValue: _this.setFieldValue,\n      setFieldsValue: _this.setFieldsValue,\n      validateFields: _this.validateFields,\n      submit: _this.submit,\n      _init: true,\n      getInternalHooks: _this.getInternalHooks\n    };\n  };\n  // ======================== Internal Hooks ========================\n  this.getInternalHooks = function (key) {\n    if (key === HOOK_MARK) {\n      _this.formHooked = true;\n      return {\n        dispatch: _this.dispatch,\n        initEntityValue: _this.initEntityValue,\n        registerField: _this.registerField,\n        useSubscribe: _this.useSubscribe,\n        setInitialValues: _this.setInitialValues,\n        destroyForm: _this.destroyForm,\n        setCallbacks: _this.setCallbacks,\n        setValidateMessages: _this.setValidateMessages,\n        getFields: _this.getFields,\n        setPreserve: _this.setPreserve,\n        getInitialValue: _this.getInitialValue,\n        registerWatch: _this.registerWatch\n      };\n    }\n    warning(false, '`getInternalHooks` is internal usage. Should not call directly.');\n    return null;\n  };\n  this.useSubscribe = function (subscribable) {\n    _this.subscribable = subscribable;\n  };\n  /**\r\n   * Record prev Form unmount fieldEntities which config preserve false.\r\n   * This need to be refill with initialValues instead of store value.\r\n   */\n  this.prevWithoutPreserves = null;\n  /**\r\n   * First time `setInitialValues` should update store with initial value\r\n   */\n  this.setInitialValues = function (initialValues, init) {\n    _this.initialValues = initialValues || {};\n    if (init) {\n      var _this$prevWithoutPres;\n      var nextStore = merge(initialValues, _this.store);\n      // We will take consider prev form unmount fields.\n      // When the field is not `preserve`, we need fill this with initialValues instead of store.\n      // eslint-disable-next-line array-callback-return\n      (_this$prevWithoutPres = _this.prevWithoutPreserves) === null || _this$prevWithoutPres === void 0 ? void 0 : _this$prevWithoutPres.map(function (_ref) {\n        var namePath = _ref.key;\n        nextStore = setValue(nextStore, namePath, getValue(initialValues, namePath));\n      });\n      _this.prevWithoutPreserves = null;\n      _this.updateStore(nextStore);\n    }\n  };\n  this.destroyForm = function () {\n    var prevWithoutPreserves = new NameMap();\n    _this.getFieldEntities(true).forEach(function (entity) {\n      if (!_this.isMergedPreserve(entity.isPreserve())) {\n        prevWithoutPreserves.set(entity.getNamePath(), true);\n      }\n    });\n    _this.prevWithoutPreserves = prevWithoutPreserves;\n  };\n  this.getInitialValue = function (namePath) {\n    var initValue = getValue(_this.initialValues, namePath);\n    // Not cloneDeep when without `namePath`\n    return namePath.length ? merge(initValue) : initValue;\n  };\n  this.setCallbacks = function (callbacks) {\n    _this.callbacks = callbacks;\n  };\n  this.setValidateMessages = function (validateMessages) {\n    _this.validateMessages = validateMessages;\n  };\n  this.setPreserve = function (preserve) {\n    _this.preserve = preserve;\n  };\n  // ============================= Watch ============================\n  this.watchList = [];\n  this.registerWatch = function (callback) {\n    _this.watchList.push(callback);\n    return function () {\n      _this.watchList = _this.watchList.filter(function (fn) {\n        return fn !== callback;\n      });\n    };\n  };\n  this.notifyWatch = function () {\n    var namePath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    // No need to cost perf when nothing need to watch\n    if (_this.watchList.length) {\n      var values = _this.getFieldsValue();\n      var allValues = _this.getFieldsValue(true);\n      _this.watchList.forEach(function (callback) {\n        callback(values, allValues, namePath);\n      });\n    }\n  };\n  // ========================== Dev Warning =========================\n  this.timeoutId = null;\n  this.warningUnhooked = function () {\n    if (process.env.NODE_ENV !== 'production' && !_this.timeoutId && typeof window !== 'undefined') {\n      _this.timeoutId = setTimeout(function () {\n        _this.timeoutId = null;\n        if (!_this.formHooked) {\n          warning(false, 'Instance created by `useForm` is not connected to any Form element. Forget to pass `form` prop?');\n        }\n      });\n    }\n  };\n  // ============================ Store =============================\n  this.updateStore = function (nextStore) {\n    _this.store = nextStore;\n  };\n  // ============================ Fields ============================\n  /**\r\n   * Get registered field entities.\r\n   * @param pure Only return field which has a `name`. Default: false\r\n   */\n  this.getFieldEntities = function () {\n    var pure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (!pure) {\n      return _this.fieldEntities;\n    }\n    return _this.fieldEntities.filter(function (field) {\n      return field.getNamePath().length;\n    });\n  };\n  this.getFieldsMap = function () {\n    var pure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var cache = new NameMap();\n    _this.getFieldEntities(pure).forEach(function (field) {\n      var namePath = field.getNamePath();\n      cache.set(namePath, field);\n    });\n    return cache;\n  };\n  this.getFieldEntitiesForNamePathList = function (nameList) {\n    if (!nameList) {\n      return _this.getFieldEntities(true);\n    }\n    var cache = _this.getFieldsMap(true);\n    return nameList.map(function (name) {\n      var namePath = getNamePath(name);\n      return cache.get(namePath) || {\n        INVALIDATE_NAME_PATH: getNamePath(name)\n      };\n    });\n  };\n  this.getFieldsValue = function (nameList, filterFunc) {\n    _this.warningUnhooked();\n    // Fill args\n    var mergedNameList;\n    var mergedFilterFunc;\n    var mergedStrict;\n    if (nameList === true || Array.isArray(nameList)) {\n      mergedNameList = nameList;\n      mergedFilterFunc = filterFunc;\n    } else if (nameList && _typeof(nameList) === 'object') {\n      mergedStrict = nameList.strict;\n      mergedFilterFunc = nameList.filter;\n    }\n    if (mergedNameList === true && !mergedFilterFunc) {\n      return _this.store;\n    }\n    var fieldEntities = _this.getFieldEntitiesForNamePathList(Array.isArray(mergedNameList) ? mergedNameList : null);\n    var filteredNameList = [];\n    fieldEntities.forEach(function (entity) {\n      var _entity$isListField;\n      var namePath = 'INVALIDATE_NAME_PATH' in entity ? entity.INVALIDATE_NAME_PATH : entity.getNamePath();\n      // Ignore when it's a list item and not specific the namePath,\n      // since parent field is already take in count\n      if (mergedStrict) {\n        var _entity$isList;\n        if ((_entity$isList = entity.isList) === null || _entity$isList === void 0 ? void 0 : _entity$isList.call(entity)) {\n          return;\n        }\n      } else if (!mergedNameList && ((_entity$isListField = entity.isListField) === null || _entity$isListField === void 0 ? void 0 : _entity$isListField.call(entity))) {\n        return;\n      }\n      if (!mergedFilterFunc) {\n        filteredNameList.push(namePath);\n      } else {\n        var meta = 'getMeta' in entity ? entity.getMeta() : null;\n        if (mergedFilterFunc(meta)) {\n          filteredNameList.push(namePath);\n        }\n      }\n    });\n    return cloneByNamePathList(_this.store, filteredNameList.map(getNamePath));\n  };\n  this.getFieldValue = function (name) {\n    _this.warningUnhooked();\n    var namePath = getNamePath(name);\n    return getValue(_this.store, namePath);\n  };\n  this.getFieldsError = function (nameList) {\n    _this.warningUnhooked();\n    var fieldEntities = _this.getFieldEntitiesForNamePathList(nameList);\n    return fieldEntities.map(function (entity, index) {\n      if (entity && !('INVALIDATE_NAME_PATH' in entity)) {\n        return {\n          name: entity.getNamePath(),\n          errors: entity.getErrors(),\n          warnings: entity.getWarnings()\n        };\n      }\n      return {\n        name: getNamePath(nameList[index]),\n        errors: [],\n        warnings: []\n      };\n    });\n  };\n  this.getFieldError = function (name) {\n    _this.warningUnhooked();\n    var namePath = getNamePath(name);\n    var fieldError = _this.getFieldsError([namePath])[0];\n    return fieldError.errors;\n  };\n  this.getFieldWarning = function (name) {\n    _this.warningUnhooked();\n    var namePath = getNamePath(name);\n    var fieldError = _this.getFieldsError([namePath])[0];\n    return fieldError.warnings;\n  };\n  this.isFieldsTouched = function () {\n    _this.warningUnhooked();\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    var arg0 = args[0],\n      arg1 = args[1];\n    var namePathList;\n    var isAllFieldsTouched = false;\n    if (args.length === 0) {\n      namePathList = null;\n    } else if (args.length === 1) {\n      if (Array.isArray(arg0)) {\n        namePathList = arg0.map(getNamePath);\n        isAllFieldsTouched = false;\n      } else {\n        namePathList = null;\n        isAllFieldsTouched = arg0;\n      }\n    } else {\n      namePathList = arg0.map(getNamePath);\n      isAllFieldsTouched = arg1;\n    }\n    var fieldEntities = _this.getFieldEntities(true);\n    var isFieldTouched = function isFieldTouched(field) {\n      return field.isFieldTouched();\n    };\n    // ===== Will get fully compare when not config namePathList =====\n    if (!namePathList) {\n      return isAllFieldsTouched ? fieldEntities.every(isFieldTouched) : fieldEntities.some(isFieldTouched);\n    }\n    // Generate a nest tree for validate\n    var map = new NameMap();\n    namePathList.forEach(function (shortNamePath) {\n      map.set(shortNamePath, []);\n    });\n    fieldEntities.forEach(function (field) {\n      var fieldNamePath = field.getNamePath();\n      // Find matched entity and put into list\n      namePathList.forEach(function (shortNamePath) {\n        if (shortNamePath.every(function (nameUnit, i) {\n          return fieldNamePath[i] === nameUnit;\n        })) {\n          map.update(shortNamePath, function (list) {\n            return [].concat(_toConsumableArray(list), [field]);\n          });\n        }\n      });\n    });\n    // Check if NameMap value is touched\n    var isNamePathListTouched = function isNamePathListTouched(entities) {\n      return entities.some(isFieldTouched);\n    };\n    var namePathListEntities = map.map(function (_ref2) {\n      var value = _ref2.value;\n      return value;\n    });\n    return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);\n  };\n  this.isFieldTouched = function (name) {\n    _this.warningUnhooked();\n    return _this.isFieldsTouched([name]);\n  };\n  this.isFieldsValidating = function (nameList) {\n    _this.warningUnhooked();\n    var fieldEntities = _this.getFieldEntities();\n    if (!nameList) {\n      return fieldEntities.some(function (testField) {\n        return testField.isFieldValidating();\n      });\n    }\n    var namePathList = nameList.map(getNamePath);\n    return fieldEntities.some(function (testField) {\n      var fieldNamePath = testField.getNamePath();\n      return containsNamePath(namePathList, fieldNamePath) && testField.isFieldValidating();\n    });\n  };\n  this.isFieldValidating = function (name) {\n    _this.warningUnhooked();\n    return _this.isFieldsValidating([name]);\n  };\n  /**\r\n   * Reset Field with field `initialValue` prop.\r\n   * Can pass `entities` or `namePathList` or just nothing.\r\n   */\n  this.resetWithFieldInitialValue = function () {\n    var info = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // Create cache\n    var cache = new NameMap();\n    var fieldEntities = _this.getFieldEntities(true);\n    fieldEntities.forEach(function (field) {\n      var initialValue = field.props.initialValue;\n      var namePath = field.getNamePath();\n      // Record only if has `initialValue`\n      if (initialValue !== undefined) {\n        var records = cache.get(namePath) || new Set();\n        records.add({\n          entity: field,\n          value: initialValue\n        });\n        cache.set(namePath, records);\n      }\n    });\n    // Reset\n    var resetWithFields = function resetWithFields(entities) {\n      entities.forEach(function (field) {\n        var initialValue = field.props.initialValue;\n        if (initialValue !== undefined) {\n          var namePath = field.getNamePath();\n          var formInitialValue = _this.getInitialValue(namePath);\n          if (formInitialValue !== undefined) {\n            // Warning if conflict with form initialValues and do not modify value\n            warning(false, \"Form already set 'initialValues' with path '\".concat(namePath.join('.'), \"'. Field can not overwrite it.\"));\n          } else {\n            var records = cache.get(namePath);\n            if (records && records.size > 1) {\n              // Warning if multiple field set `initialValue`and do not modify value\n              warning(false, \"Multiple Field with path '\".concat(namePath.join('.'), \"' set 'initialValue'. Can not decide which one to pick.\"));\n            } else if (records) {\n              var originValue = _this.getFieldValue(namePath);\n              // Set `initialValue`\n              if (!info.skipExist || originValue === undefined) {\n                _this.updateStore(setValue(_this.store, namePath, _toConsumableArray(records)[0].value));\n              }\n            }\n          }\n        }\n      });\n    };\n    var requiredFieldEntities;\n    if (info.entities) {\n      requiredFieldEntities = info.entities;\n    } else if (info.namePathList) {\n      requiredFieldEntities = [];\n      info.namePathList.forEach(function (namePath) {\n        var records = cache.get(namePath);\n        if (records) {\n          var _requiredFieldEntitie;\n          (_requiredFieldEntitie = requiredFieldEntities).push.apply(_requiredFieldEntitie, _toConsumableArray(_toConsumableArray(records).map(function (r) {\n            return r.entity;\n          })));\n        }\n      });\n    } else {\n      requiredFieldEntities = fieldEntities;\n    }\n    resetWithFields(requiredFieldEntities);\n  };\n  this.resetFields = function (nameList) {\n    _this.warningUnhooked();\n    var prevStore = _this.store;\n    if (!nameList) {\n      _this.updateStore(merge(_this.initialValues));\n      _this.resetWithFieldInitialValue();\n      _this.notifyObservers(prevStore, null, {\n        type: 'reset'\n      });\n      _this.notifyWatch();\n      return;\n    }\n    // Reset by `nameList`\n    var namePathList = nameList.map(getNamePath);\n    namePathList.forEach(function (namePath) {\n      var initialValue = _this.getInitialValue(namePath);\n      _this.updateStore(setValue(_this.store, namePath, initialValue));\n    });\n    _this.resetWithFieldInitialValue({\n      namePathList: namePathList\n    });\n    _this.notifyObservers(prevStore, namePathList, {\n      type: 'reset'\n    });\n    _this.notifyWatch(namePathList);\n  };\n  this.setFields = function (fields) {\n    _this.warningUnhooked();\n    var prevStore = _this.store;\n    var namePathList = [];\n    fields.forEach(function (fieldData) {\n      var name = fieldData.name,\n        data = _objectWithoutProperties(fieldData, _excluded);\n      var namePath = getNamePath(name);\n      namePathList.push(namePath);\n      // Value\n      if ('value' in data) {\n        _this.updateStore(setValue(_this.store, namePath, data.value));\n      }\n      _this.notifyObservers(prevStore, [namePath], {\n        type: 'setField',\n        data: fieldData\n      });\n    });\n    _this.notifyWatch(namePathList);\n  };\n  this.getFields = function () {\n    var entities = _this.getFieldEntities(true);\n    var fields = entities.map(function (field) {\n      var namePath = field.getNamePath();\n      var meta = field.getMeta();\n      var fieldData = _objectSpread(_objectSpread({}, meta), {}, {\n        name: namePath,\n        value: _this.getFieldValue(namePath)\n      });\n      Object.defineProperty(fieldData, 'originRCField', {\n        value: true\n      });\n      return fieldData;\n    });\n    return fields;\n  };\n  // =========================== Observer ===========================\n  /**\r\n   * This only trigger when a field is on constructor to avoid we get initialValue too late\r\n   */\n  this.initEntityValue = function (entity) {\n    var initialValue = entity.props.initialValue;\n    if (initialValue !== undefined) {\n      var namePath = entity.getNamePath();\n      var prevValue = getValue(_this.store, namePath);\n      if (prevValue === undefined) {\n        _this.updateStore(setValue(_this.store, namePath, initialValue));\n      }\n    }\n  };\n  this.isMergedPreserve = function (fieldPreserve) {\n    var mergedPreserve = fieldPreserve !== undefined ? fieldPreserve : _this.preserve;\n    return mergedPreserve !== null && mergedPreserve !== void 0 ? mergedPreserve : true;\n  };\n  this.registerField = function (entity) {\n    _this.fieldEntities.push(entity);\n    var namePath = entity.getNamePath();\n    _this.notifyWatch([namePath]);\n    // Set initial values\n    if (entity.props.initialValue !== undefined) {\n      var prevStore = _this.store;\n      _this.resetWithFieldInitialValue({\n        entities: [entity],\n        skipExist: true\n      });\n      _this.notifyObservers(prevStore, [entity.getNamePath()], {\n        type: 'valueUpdate',\n        source: 'internal'\n      });\n    }\n    // un-register field callback\n    return function (isListField, preserve) {\n      var subNamePath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      _this.fieldEntities = _this.fieldEntities.filter(function (item) {\n        return item !== entity;\n      });\n      // Clean up store value if not preserve\n      if (!_this.isMergedPreserve(preserve) && (!isListField || subNamePath.length > 1)) {\n        var defaultValue = isListField ? undefined : _this.getInitialValue(namePath);\n        if (namePath.length && _this.getFieldValue(namePath) !== defaultValue && _this.fieldEntities.every(function (field) {\n          return (\n            // Only reset when no namePath exist\n            !matchNamePath(field.getNamePath(), namePath)\n          );\n        })) {\n          var _prevStore = _this.store;\n          _this.updateStore(setValue(_prevStore, namePath, defaultValue, true));\n          // Notify that field is unmount\n          _this.notifyObservers(_prevStore, [namePath], {\n            type: 'remove'\n          });\n          // Dependencies update\n          _this.triggerDependenciesUpdate(_prevStore, namePath);\n        }\n      }\n      _this.notifyWatch([namePath]);\n    };\n  };\n  this.dispatch = function (action) {\n    switch (action.type) {\n      case 'updateValue':\n        {\n          var namePath = action.namePath,\n            value = action.value;\n          _this.updateValue(namePath, value);\n          break;\n        }\n      case 'validateField':\n        {\n          var _namePath = action.namePath,\n            triggerName = action.triggerName;\n          _this.validateFields([_namePath], {\n            triggerName: triggerName\n          });\n          break;\n        }\n      default:\n      // Currently we don't have other action. Do nothing.\n    }\n  };\n\n  this.notifyObservers = function (prevStore, namePathList, info) {\n    if (_this.subscribable) {\n      var mergedInfo = _objectSpread(_objectSpread({}, info), {}, {\n        store: _this.getFieldsValue(true)\n      });\n      _this.getFieldEntities().forEach(function (_ref3) {\n        var onStoreChange = _ref3.onStoreChange;\n        onStoreChange(prevStore, namePathList, mergedInfo);\n      });\n    } else {\n      _this.forceRootUpdate();\n    }\n  };\n  /**\r\n   * Notify dependencies children with parent update\r\n   * We need delay to trigger validate in case Field is under render props\r\n   */\n  this.triggerDependenciesUpdate = function (prevStore, namePath) {\n    var childrenFields = _this.getDependencyChildrenFields(namePath);\n    if (childrenFields.length) {\n      _this.validateFields(childrenFields);\n    }\n    _this.notifyObservers(prevStore, childrenFields, {\n      type: 'dependenciesUpdate',\n      relatedFields: [namePath].concat(_toConsumableArray(childrenFields))\n    });\n    return childrenFields;\n  };\n  this.updateValue = function (name, value) {\n    var namePath = getNamePath(name);\n    var prevStore = _this.store;\n    _this.updateStore(setValue(_this.store, namePath, value));\n    _this.notifyObservers(prevStore, [namePath], {\n      type: 'valueUpdate',\n      source: 'internal'\n    });\n    _this.notifyWatch([namePath]);\n    // Dependencies update\n    var childrenFields = _this.triggerDependenciesUpdate(prevStore, namePath);\n    // trigger callback function\n    var onValuesChange = _this.callbacks.onValuesChange;\n    if (onValuesChange) {\n      var changedValues = cloneByNamePathList(_this.store, [namePath]);\n      onValuesChange(changedValues, _this.getFieldsValue());\n    }\n    _this.triggerOnFieldsChange([namePath].concat(_toConsumableArray(childrenFields)));\n  };\n  // Let all child Field get update.\n  this.setFieldsValue = function (store) {\n    _this.warningUnhooked();\n    var prevStore = _this.store;\n    if (store) {\n      var nextStore = merge(_this.store, store);\n      _this.updateStore(nextStore);\n    }\n    _this.notifyObservers(prevStore, null, {\n      type: 'valueUpdate',\n      source: 'external'\n    });\n    _this.notifyWatch();\n  };\n  this.setFieldValue = function (name, value) {\n    _this.setFields([{\n      name: name,\n      value: value\n    }]);\n  };\n  this.getDependencyChildrenFields = function (rootNamePath) {\n    var children = new Set();\n    var childrenFields = [];\n    var dependencies2fields = new NameMap();\n    /**\r\n     * Generate maps\r\n     * Can use cache to save perf if user report performance issue with this\r\n     */\n    _this.getFieldEntities().forEach(function (field) {\n      var dependencies = field.props.dependencies;\n      (dependencies || []).forEach(function (dependency) {\n        var dependencyNamePath = getNamePath(dependency);\n        dependencies2fields.update(dependencyNamePath, function () {\n          var fields = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Set();\n          fields.add(field);\n          return fields;\n        });\n      });\n    });\n    var fillChildren = function fillChildren(namePath) {\n      var fields = dependencies2fields.get(namePath) || new Set();\n      fields.forEach(function (field) {\n        if (!children.has(field)) {\n          children.add(field);\n          var fieldNamePath = field.getNamePath();\n          if (field.isFieldDirty() && fieldNamePath.length) {\n            childrenFields.push(fieldNamePath);\n            fillChildren(fieldNamePath);\n          }\n        }\n      });\n    };\n    fillChildren(rootNamePath);\n    return childrenFields;\n  };\n  this.triggerOnFieldsChange = function (namePathList, filedErrors) {\n    var onFieldsChange = _this.callbacks.onFieldsChange;\n    if (onFieldsChange) {\n      var fields = _this.getFields();\n      /**\r\n       * Fill errors since `fields` may be replaced by controlled fields\r\n       */\n      if (filedErrors) {\n        var cache = new NameMap();\n        filedErrors.forEach(function (_ref4) {\n          var name = _ref4.name,\n            errors = _ref4.errors;\n          cache.set(name, errors);\n        });\n        fields.forEach(function (field) {\n          // eslint-disable-next-line no-param-reassign\n          field.errors = cache.get(field.name) || field.errors;\n        });\n      }\n      var changedFields = fields.filter(function (_ref5) {\n        var fieldName = _ref5.name;\n        return containsNamePath(namePathList, fieldName);\n      });\n      if (changedFields.length) {\n        onFieldsChange(changedFields, fields);\n      }\n    }\n  };\n  // =========================== Validate ===========================\n  this.validateFields = function (arg1, arg2) {\n    _this.warningUnhooked();\n    var nameList;\n    var options;\n    if (Array.isArray(arg1) || typeof arg1 === 'string' || typeof arg2 === 'string') {\n      nameList = arg1;\n      options = arg2;\n    } else {\n      options = arg1;\n    }\n    var provideNameList = !!nameList;\n    var namePathList = provideNameList ? nameList.map(getNamePath) : [];\n    // Collect result in promise list\n    var promiseList = [];\n    // We temp save the path which need trigger for `onFieldsChange`\n    var TMP_SPLIT = String(Date.now());\n    var validateNamePathList = new Set();\n    _this.getFieldEntities(true).forEach(function (field) {\n      var _options;\n      // Add field if not provide `nameList`\n      if (!provideNameList) {\n        namePathList.push(field.getNamePath());\n      }\n      /**\r\n       * Recursive validate if configured.\r\n       * TODO: perf improvement @zombieJ\r\n       */\n      if (((_options = options) === null || _options === void 0 ? void 0 : _options.recursive) && provideNameList) {\n        var namePath = field.getNamePath();\n        if (\n        // nameList[i] === undefined 说明是以 nameList 开头的\n        // ['name'] -> ['name','list']\n        namePath.every(function (nameUnit, i) {\n          return nameList[i] === nameUnit || nameList[i] === undefined;\n        })) {\n          namePathList.push(namePath);\n        }\n      }\n      // Skip if without rule\n      if (!field.props.rules || !field.props.rules.length) {\n        return;\n      }\n      var fieldNamePath = field.getNamePath();\n      validateNamePathList.add(fieldNamePath.join(TMP_SPLIT));\n      // Add field validate rule in to promise list\n      if (!provideNameList || containsNamePath(namePathList, fieldNamePath)) {\n        var promise = field.validateRules(_objectSpread({\n          validateMessages: _objectSpread(_objectSpread({}, defaultValidateMessages), _this.validateMessages)\n        }, options));\n        // Wrap promise with field\n        promiseList.push(promise.then(function () {\n          return {\n            name: fieldNamePath,\n            errors: [],\n            warnings: []\n          };\n        }).catch(function (ruleErrors) {\n          var _ruleErrors$forEach;\n          var mergedErrors = [];\n          var mergedWarnings = [];\n          (_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 ? void 0 : _ruleErrors$forEach.call(ruleErrors, function (_ref6) {\n            var warningOnly = _ref6.rule.warningOnly,\n              errors = _ref6.errors;\n            if (warningOnly) {\n              mergedWarnings.push.apply(mergedWarnings, _toConsumableArray(errors));\n            } else {\n              mergedErrors.push.apply(mergedErrors, _toConsumableArray(errors));\n            }\n          });\n          if (mergedErrors.length) {\n            return Promise.reject({\n              name: fieldNamePath,\n              errors: mergedErrors,\n              warnings: mergedWarnings\n            });\n          }\n          return {\n            name: fieldNamePath,\n            errors: mergedErrors,\n            warnings: mergedWarnings\n          };\n        }));\n      }\n    });\n    var summaryPromise = allPromiseFinish(promiseList);\n    _this.lastValidatePromise = summaryPromise;\n    // Notify fields with rule that validate has finished and need update\n    summaryPromise.catch(function (results) {\n      return results;\n    }).then(function (results) {\n      var resultNamePathList = results.map(function (_ref7) {\n        var name = _ref7.name;\n        return name;\n      });\n      _this.notifyObservers(_this.store, resultNamePathList, {\n        type: 'validateFinish'\n      });\n      _this.triggerOnFieldsChange(resultNamePathList, results);\n    });\n    var returnPromise = summaryPromise.then(function () {\n      if (_this.lastValidatePromise === summaryPromise) {\n        return Promise.resolve(_this.getFieldsValue(namePathList));\n      }\n      return Promise.reject([]);\n    }).catch(function (results) {\n      var errorList = results.filter(function (result) {\n        return result && result.errors.length;\n      });\n      return Promise.reject({\n        values: _this.getFieldsValue(namePathList),\n        errorFields: errorList,\n        outOfDate: _this.lastValidatePromise !== summaryPromise\n      });\n    });\n    // Do not throw in console\n    returnPromise.catch(function (e) {\n      return e;\n    });\n    // `validating` changed. Trigger `onFieldsChange`\n    var triggerNamePathList = namePathList.filter(function (namePath) {\n      return validateNamePathList.has(namePath.join(TMP_SPLIT));\n    });\n    _this.triggerOnFieldsChange(triggerNamePathList);\n    return returnPromise;\n  };\n  // ============================ Submit ============================\n  this.submit = function () {\n    _this.warningUnhooked();\n    _this.validateFields().then(function (values) {\n      var onFinish = _this.callbacks.onFinish;\n      if (onFinish) {\n        try {\n          onFinish(values);\n        } catch (err) {\n          // Should print error if user `onFinish` callback failed\n          console.error(err);\n        }\n      }\n    }).catch(function (e) {\n      var onFinishFailed = _this.callbacks.onFinishFailed;\n      if (onFinishFailed) {\n        onFinishFailed(e);\n      }\n    });\n  };\n  this.forceRootUpdate = forceRootUpdate;\n});\nfunction useForm(form) {\n  var formRef = React.useRef();\n  var _React$useState = React.useState({}),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    forceUpdate = _React$useState2[1];\n  if (!formRef.current) {\n    if (form) {\n      formRef.current = form;\n    } else {\n      // Create a new FormStore if not provided\n      var forceReRender = function forceReRender() {\n        forceUpdate({});\n      };\n      var formStore = new FormStore(forceReRender);\n      formRef.current = formStore.getForm();\n    }\n  }\n  return [formRef.current];\n}\nexport default useForm;","map":{"version":3,"names":["_slicedToArray","_objectSpread","_objectWithoutProperties","_toConsumableArray","_typeof","_createClass","_classCallCheck","_excluded","warning","React","HOOK_MARK","allPromiseFinish","merge","defaultValidateMessages","NameMap","cloneByNamePathList","containsNamePath","getNamePath","getValue","matchNamePath","setValue","FormStore","forceRootUpdate","_this","formHooked","subscribable","store","fieldEntities","initialValues","callbacks","validateMessages","preserve","lastValidatePromise","getForm","getFieldValue","getFieldsValue","getFieldError","getFieldWarning","getFieldsError","isFieldsTouched","isFieldTouched","isFieldValidating","isFieldsValidating","resetFields","setFields","setFieldValue","setFieldsValue","validateFields","submit","_init","getInternalHooks","key","dispatch","initEntityValue","registerField","useSubscribe","setInitialValues","destroyForm","setCallbacks","setValidateMessages","getFields","setPreserve","getInitialValue","registerWatch","prevWithoutPreserves","init","_this$prevWithoutPres","nextStore","map","_ref","namePath","updateStore","getFieldEntities","forEach","entity","isMergedPreserve","isPreserve","set","initValue","length","watchList","callback","push","filter","fn","notifyWatch","arguments","undefined","values","allValues","timeoutId","warningUnhooked","process","env","NODE_ENV","window","setTimeout","pure","field","getFieldsMap","cache","getFieldEntitiesForNamePathList","nameList","name","get","INVALIDATE_NAME_PATH","filterFunc","mergedNameList","mergedFilterFunc","mergedStrict","Array","isArray","strict","filteredNameList","_entity$isListField","_entity$isList","isList","call","isListField","meta","getMeta","index","errors","getErrors","warnings","getWarnings","fieldError","_len","args","_key","arg0","arg1","namePathList","isAllFieldsTouched","every","some","shortNamePath","fieldNamePath","nameUnit","i","update","list","concat","isNamePathListTouched","entities","namePathListEntities","_ref2","value","testField","resetWithFieldInitialValue","info","initialValue","props","records","Set","add","resetWithFields","formInitialValue","join","size","originValue","skipExist","requiredFieldEntities","_requiredFieldEntitie","apply","r","prevStore","notifyObservers","type","fields","fieldData","data","Object","defineProperty","prevValue","fieldPreserve","mergedPreserve","source","subNamePath","item","defaultValue","_prevStore","triggerDependenciesUpdate","action","updateValue","_namePath","triggerName","mergedInfo","_ref3","onStoreChange","childrenFields","getDependencyChildrenFields","relatedFields","onValuesChange","changedValues","triggerOnFieldsChange","rootNamePath","children","dependencies2fields","dependencies","dependency","dependencyNamePath","fillChildren","has","isFieldDirty","filedErrors","onFieldsChange","_ref4","changedFields","_ref5","fieldName","arg2","options","provideNameList","promiseList","TMP_SPLIT","String","Date","now","validateNamePathList","_options","recursive","rules","promise","validateRules","then","catch","ruleErrors","_ruleErrors$forEach","mergedErrors","mergedWarnings","_ref6","warningOnly","rule","Promise","reject","summaryPromise","results","resultNamePathList","_ref7","returnPromise","resolve","errorList","result","errorFields","outOfDate","e","triggerNamePathList","onFinish","err","console","error","onFinishFailed","useForm","form","formRef","useRef","_React$useState","useState","_React$useState2","forceUpdate","current","forceReRender","formStore"],"sources":["C:/Users/trung/OneDrive/Desktop/PRN231(BL5)/Project_ManageStorage/frontend/node_modules/rc-field-form/es/useForm.js"],"sourcesContent":["import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\r\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\r\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\r\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\r\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\r\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\r\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\r\nvar _excluded = [\"name\"];\r\nimport warning from \"rc-util/es/warning\";\r\nimport * as React from 'react';\r\nimport { HOOK_MARK } from './FieldContext';\r\nimport { allPromiseFinish } from './utils/asyncUtil';\r\nimport { merge } from \"rc-util/es/utils/set\";\r\nimport { defaultValidateMessages } from './utils/messages';\r\nimport NameMap from './utils/NameMap';\r\nimport { cloneByNamePathList, containsNamePath, getNamePath, getValue, matchNamePath, setValue } from './utils/valueUtil';\r\nexport var FormStore = /*#__PURE__*/_createClass(function FormStore(forceRootUpdate) {\r\n  var _this = this;\r\n  _classCallCheck(this, FormStore);\r\n  this.formHooked = false;\r\n  this.forceRootUpdate = void 0;\r\n  this.subscribable = true;\r\n  this.store = {};\r\n  this.fieldEntities = [];\r\n  this.initialValues = {};\r\n  this.callbacks = {};\r\n  this.validateMessages = null;\r\n  this.preserve = null;\r\n  this.lastValidatePromise = null;\r\n  this.getForm = function () {\r\n    return {\r\n      getFieldValue: _this.getFieldValue,\r\n      getFieldsValue: _this.getFieldsValue,\r\n      getFieldError: _this.getFieldError,\r\n      getFieldWarning: _this.getFieldWarning,\r\n      getFieldsError: _this.getFieldsError,\r\n      isFieldsTouched: _this.isFieldsTouched,\r\n      isFieldTouched: _this.isFieldTouched,\r\n      isFieldValidating: _this.isFieldValidating,\r\n      isFieldsValidating: _this.isFieldsValidating,\r\n      resetFields: _this.resetFields,\r\n      setFields: _this.setFields,\r\n      setFieldValue: _this.setFieldValue,\r\n      setFieldsValue: _this.setFieldsValue,\r\n      validateFields: _this.validateFields,\r\n      submit: _this.submit,\r\n      _init: true,\r\n      getInternalHooks: _this.getInternalHooks\r\n    };\r\n  };\r\n  // ======================== Internal Hooks ========================\r\n  this.getInternalHooks = function (key) {\r\n    if (key === HOOK_MARK) {\r\n      _this.formHooked = true;\r\n      return {\r\n        dispatch: _this.dispatch,\r\n        initEntityValue: _this.initEntityValue,\r\n        registerField: _this.registerField,\r\n        useSubscribe: _this.useSubscribe,\r\n        setInitialValues: _this.setInitialValues,\r\n        destroyForm: _this.destroyForm,\r\n        setCallbacks: _this.setCallbacks,\r\n        setValidateMessages: _this.setValidateMessages,\r\n        getFields: _this.getFields,\r\n        setPreserve: _this.setPreserve,\r\n        getInitialValue: _this.getInitialValue,\r\n        registerWatch: _this.registerWatch\r\n      };\r\n    }\r\n    warning(false, '`getInternalHooks` is internal usage. Should not call directly.');\r\n    return null;\r\n  };\r\n  this.useSubscribe = function (subscribable) {\r\n    _this.subscribable = subscribable;\r\n  };\r\n  /**\r\n   * Record prev Form unmount fieldEntities which config preserve false.\r\n   * This need to be refill with initialValues instead of store value.\r\n   */\r\n  this.prevWithoutPreserves = null;\r\n  /**\r\n   * First time `setInitialValues` should update store with initial value\r\n   */\r\n  this.setInitialValues = function (initialValues, init) {\r\n    _this.initialValues = initialValues || {};\r\n    if (init) {\r\n      var _this$prevWithoutPres;\r\n      var nextStore = merge(initialValues, _this.store);\r\n      // We will take consider prev form unmount fields.\r\n      // When the field is not `preserve`, we need fill this with initialValues instead of store.\r\n      // eslint-disable-next-line array-callback-return\r\n      (_this$prevWithoutPres = _this.prevWithoutPreserves) === null || _this$prevWithoutPres === void 0 ? void 0 : _this$prevWithoutPres.map(function (_ref) {\r\n        var namePath = _ref.key;\r\n        nextStore = setValue(nextStore, namePath, getValue(initialValues, namePath));\r\n      });\r\n      _this.prevWithoutPreserves = null;\r\n      _this.updateStore(nextStore);\r\n    }\r\n  };\r\n  this.destroyForm = function () {\r\n    var prevWithoutPreserves = new NameMap();\r\n    _this.getFieldEntities(true).forEach(function (entity) {\r\n      if (!_this.isMergedPreserve(entity.isPreserve())) {\r\n        prevWithoutPreserves.set(entity.getNamePath(), true);\r\n      }\r\n    });\r\n    _this.prevWithoutPreserves = prevWithoutPreserves;\r\n  };\r\n  this.getInitialValue = function (namePath) {\r\n    var initValue = getValue(_this.initialValues, namePath);\r\n    // Not cloneDeep when without `namePath`\r\n    return namePath.length ? merge(initValue) : initValue;\r\n  };\r\n  this.setCallbacks = function (callbacks) {\r\n    _this.callbacks = callbacks;\r\n  };\r\n  this.setValidateMessages = function (validateMessages) {\r\n    _this.validateMessages = validateMessages;\r\n  };\r\n  this.setPreserve = function (preserve) {\r\n    _this.preserve = preserve;\r\n  };\r\n  // ============================= Watch ============================\r\n  this.watchList = [];\r\n  this.registerWatch = function (callback) {\r\n    _this.watchList.push(callback);\r\n    return function () {\r\n      _this.watchList = _this.watchList.filter(function (fn) {\r\n        return fn !== callback;\r\n      });\r\n    };\r\n  };\r\n  this.notifyWatch = function () {\r\n    var namePath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\r\n    // No need to cost perf when nothing need to watch\r\n    if (_this.watchList.length) {\r\n      var values = _this.getFieldsValue();\r\n      var allValues = _this.getFieldsValue(true);\r\n      _this.watchList.forEach(function (callback) {\r\n        callback(values, allValues, namePath);\r\n      });\r\n    }\r\n  };\r\n  // ========================== Dev Warning =========================\r\n  this.timeoutId = null;\r\n  this.warningUnhooked = function () {\r\n    if (process.env.NODE_ENV !== 'production' && !_this.timeoutId && typeof window !== 'undefined') {\r\n      _this.timeoutId = setTimeout(function () {\r\n        _this.timeoutId = null;\r\n        if (!_this.formHooked) {\r\n          warning(false, 'Instance created by `useForm` is not connected to any Form element. Forget to pass `form` prop?');\r\n        }\r\n      });\r\n    }\r\n  };\r\n  // ============================ Store =============================\r\n  this.updateStore = function (nextStore) {\r\n    _this.store = nextStore;\r\n  };\r\n  // ============================ Fields ============================\r\n  /**\r\n   * Get registered field entities.\r\n   * @param pure Only return field which has a `name`. Default: false\r\n   */\r\n  this.getFieldEntities = function () {\r\n    var pure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\r\n    if (!pure) {\r\n      return _this.fieldEntities;\r\n    }\r\n    return _this.fieldEntities.filter(function (field) {\r\n      return field.getNamePath().length;\r\n    });\r\n  };\r\n  this.getFieldsMap = function () {\r\n    var pure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\r\n    var cache = new NameMap();\r\n    _this.getFieldEntities(pure).forEach(function (field) {\r\n      var namePath = field.getNamePath();\r\n      cache.set(namePath, field);\r\n    });\r\n    return cache;\r\n  };\r\n  this.getFieldEntitiesForNamePathList = function (nameList) {\r\n    if (!nameList) {\r\n      return _this.getFieldEntities(true);\r\n    }\r\n    var cache = _this.getFieldsMap(true);\r\n    return nameList.map(function (name) {\r\n      var namePath = getNamePath(name);\r\n      return cache.get(namePath) || {\r\n        INVALIDATE_NAME_PATH: getNamePath(name)\r\n      };\r\n    });\r\n  };\r\n  this.getFieldsValue = function (nameList, filterFunc) {\r\n    _this.warningUnhooked();\r\n    // Fill args\r\n    var mergedNameList;\r\n    var mergedFilterFunc;\r\n    var mergedStrict;\r\n    if (nameList === true || Array.isArray(nameList)) {\r\n      mergedNameList = nameList;\r\n      mergedFilterFunc = filterFunc;\r\n    } else if (nameList && _typeof(nameList) === 'object') {\r\n      mergedStrict = nameList.strict;\r\n      mergedFilterFunc = nameList.filter;\r\n    }\r\n    if (mergedNameList === true && !mergedFilterFunc) {\r\n      return _this.store;\r\n    }\r\n    var fieldEntities = _this.getFieldEntitiesForNamePathList(Array.isArray(mergedNameList) ? mergedNameList : null);\r\n    var filteredNameList = [];\r\n    fieldEntities.forEach(function (entity) {\r\n      var _entity$isListField;\r\n      var namePath = 'INVALIDATE_NAME_PATH' in entity ? entity.INVALIDATE_NAME_PATH : entity.getNamePath();\r\n      // Ignore when it's a list item and not specific the namePath,\r\n      // since parent field is already take in count\r\n      if (mergedStrict) {\r\n        var _entity$isList;\r\n        if ((_entity$isList = entity.isList) === null || _entity$isList === void 0 ? void 0 : _entity$isList.call(entity)) {\r\n          return;\r\n        }\r\n      } else if (!mergedNameList && ((_entity$isListField = entity.isListField) === null || _entity$isListField === void 0 ? void 0 : _entity$isListField.call(entity))) {\r\n        return;\r\n      }\r\n      if (!mergedFilterFunc) {\r\n        filteredNameList.push(namePath);\r\n      } else {\r\n        var meta = 'getMeta' in entity ? entity.getMeta() : null;\r\n        if (mergedFilterFunc(meta)) {\r\n          filteredNameList.push(namePath);\r\n        }\r\n      }\r\n    });\r\n    return cloneByNamePathList(_this.store, filteredNameList.map(getNamePath));\r\n  };\r\n  this.getFieldValue = function (name) {\r\n    _this.warningUnhooked();\r\n    var namePath = getNamePath(name);\r\n    return getValue(_this.store, namePath);\r\n  };\r\n  this.getFieldsError = function (nameList) {\r\n    _this.warningUnhooked();\r\n    var fieldEntities = _this.getFieldEntitiesForNamePathList(nameList);\r\n    return fieldEntities.map(function (entity, index) {\r\n      if (entity && !('INVALIDATE_NAME_PATH' in entity)) {\r\n        return {\r\n          name: entity.getNamePath(),\r\n          errors: entity.getErrors(),\r\n          warnings: entity.getWarnings()\r\n        };\r\n      }\r\n      return {\r\n        name: getNamePath(nameList[index]),\r\n        errors: [],\r\n        warnings: []\r\n      };\r\n    });\r\n  };\r\n  this.getFieldError = function (name) {\r\n    _this.warningUnhooked();\r\n    var namePath = getNamePath(name);\r\n    var fieldError = _this.getFieldsError([namePath])[0];\r\n    return fieldError.errors;\r\n  };\r\n  this.getFieldWarning = function (name) {\r\n    _this.warningUnhooked();\r\n    var namePath = getNamePath(name);\r\n    var fieldError = _this.getFieldsError([namePath])[0];\r\n    return fieldError.warnings;\r\n  };\r\n  this.isFieldsTouched = function () {\r\n    _this.warningUnhooked();\r\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\r\n      args[_key] = arguments[_key];\r\n    }\r\n    var arg0 = args[0],\r\n      arg1 = args[1];\r\n    var namePathList;\r\n    var isAllFieldsTouched = false;\r\n    if (args.length === 0) {\r\n      namePathList = null;\r\n    } else if (args.length === 1) {\r\n      if (Array.isArray(arg0)) {\r\n        namePathList = arg0.map(getNamePath);\r\n        isAllFieldsTouched = false;\r\n      } else {\r\n        namePathList = null;\r\n        isAllFieldsTouched = arg0;\r\n      }\r\n    } else {\r\n      namePathList = arg0.map(getNamePath);\r\n      isAllFieldsTouched = arg1;\r\n    }\r\n    var fieldEntities = _this.getFieldEntities(true);\r\n    var isFieldTouched = function isFieldTouched(field) {\r\n      return field.isFieldTouched();\r\n    };\r\n    // ===== Will get fully compare when not config namePathList =====\r\n    if (!namePathList) {\r\n      return isAllFieldsTouched ? fieldEntities.every(isFieldTouched) : fieldEntities.some(isFieldTouched);\r\n    }\r\n    // Generate a nest tree for validate\r\n    var map = new NameMap();\r\n    namePathList.forEach(function (shortNamePath) {\r\n      map.set(shortNamePath, []);\r\n    });\r\n    fieldEntities.forEach(function (field) {\r\n      var fieldNamePath = field.getNamePath();\r\n      // Find matched entity and put into list\r\n      namePathList.forEach(function (shortNamePath) {\r\n        if (shortNamePath.every(function (nameUnit, i) {\r\n          return fieldNamePath[i] === nameUnit;\r\n        })) {\r\n          map.update(shortNamePath, function (list) {\r\n            return [].concat(_toConsumableArray(list), [field]);\r\n          });\r\n        }\r\n      });\r\n    });\r\n    // Check if NameMap value is touched\r\n    var isNamePathListTouched = function isNamePathListTouched(entities) {\r\n      return entities.some(isFieldTouched);\r\n    };\r\n    var namePathListEntities = map.map(function (_ref2) {\r\n      var value = _ref2.value;\r\n      return value;\r\n    });\r\n    return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);\r\n  };\r\n  this.isFieldTouched = function (name) {\r\n    _this.warningUnhooked();\r\n    return _this.isFieldsTouched([name]);\r\n  };\r\n  this.isFieldsValidating = function (nameList) {\r\n    _this.warningUnhooked();\r\n    var fieldEntities = _this.getFieldEntities();\r\n    if (!nameList) {\r\n      return fieldEntities.some(function (testField) {\r\n        return testField.isFieldValidating();\r\n      });\r\n    }\r\n    var namePathList = nameList.map(getNamePath);\r\n    return fieldEntities.some(function (testField) {\r\n      var fieldNamePath = testField.getNamePath();\r\n      return containsNamePath(namePathList, fieldNamePath) && testField.isFieldValidating();\r\n    });\r\n  };\r\n  this.isFieldValidating = function (name) {\r\n    _this.warningUnhooked();\r\n    return _this.isFieldsValidating([name]);\r\n  };\r\n  /**\r\n   * Reset Field with field `initialValue` prop.\r\n   * Can pass `entities` or `namePathList` or just nothing.\r\n   */\r\n  this.resetWithFieldInitialValue = function () {\r\n    var info = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n    // Create cache\r\n    var cache = new NameMap();\r\n    var fieldEntities = _this.getFieldEntities(true);\r\n    fieldEntities.forEach(function (field) {\r\n      var initialValue = field.props.initialValue;\r\n      var namePath = field.getNamePath();\r\n      // Record only if has `initialValue`\r\n      if (initialValue !== undefined) {\r\n        var records = cache.get(namePath) || new Set();\r\n        records.add({\r\n          entity: field,\r\n          value: initialValue\r\n        });\r\n        cache.set(namePath, records);\r\n      }\r\n    });\r\n    // Reset\r\n    var resetWithFields = function resetWithFields(entities) {\r\n      entities.forEach(function (field) {\r\n        var initialValue = field.props.initialValue;\r\n        if (initialValue !== undefined) {\r\n          var namePath = field.getNamePath();\r\n          var formInitialValue = _this.getInitialValue(namePath);\r\n          if (formInitialValue !== undefined) {\r\n            // Warning if conflict with form initialValues and do not modify value\r\n            warning(false, \"Form already set 'initialValues' with path '\".concat(namePath.join('.'), \"'. Field can not overwrite it.\"));\r\n          } else {\r\n            var records = cache.get(namePath);\r\n            if (records && records.size > 1) {\r\n              // Warning if multiple field set `initialValue`and do not modify value\r\n              warning(false, \"Multiple Field with path '\".concat(namePath.join('.'), \"' set 'initialValue'. Can not decide which one to pick.\"));\r\n            } else if (records) {\r\n              var originValue = _this.getFieldValue(namePath);\r\n              // Set `initialValue`\r\n              if (!info.skipExist || originValue === undefined) {\r\n                _this.updateStore(setValue(_this.store, namePath, _toConsumableArray(records)[0].value));\r\n              }\r\n            }\r\n          }\r\n        }\r\n      });\r\n    };\r\n    var requiredFieldEntities;\r\n    if (info.entities) {\r\n      requiredFieldEntities = info.entities;\r\n    } else if (info.namePathList) {\r\n      requiredFieldEntities = [];\r\n      info.namePathList.forEach(function (namePath) {\r\n        var records = cache.get(namePath);\r\n        if (records) {\r\n          var _requiredFieldEntitie;\r\n          (_requiredFieldEntitie = requiredFieldEntities).push.apply(_requiredFieldEntitie, _toConsumableArray(_toConsumableArray(records).map(function (r) {\r\n            return r.entity;\r\n          })));\r\n        }\r\n      });\r\n    } else {\r\n      requiredFieldEntities = fieldEntities;\r\n    }\r\n    resetWithFields(requiredFieldEntities);\r\n  };\r\n  this.resetFields = function (nameList) {\r\n    _this.warningUnhooked();\r\n    var prevStore = _this.store;\r\n    if (!nameList) {\r\n      _this.updateStore(merge(_this.initialValues));\r\n      _this.resetWithFieldInitialValue();\r\n      _this.notifyObservers(prevStore, null, {\r\n        type: 'reset'\r\n      });\r\n      _this.notifyWatch();\r\n      return;\r\n    }\r\n    // Reset by `nameList`\r\n    var namePathList = nameList.map(getNamePath);\r\n    namePathList.forEach(function (namePath) {\r\n      var initialValue = _this.getInitialValue(namePath);\r\n      _this.updateStore(setValue(_this.store, namePath, initialValue));\r\n    });\r\n    _this.resetWithFieldInitialValue({\r\n      namePathList: namePathList\r\n    });\r\n    _this.notifyObservers(prevStore, namePathList, {\r\n      type: 'reset'\r\n    });\r\n    _this.notifyWatch(namePathList);\r\n  };\r\n  this.setFields = function (fields) {\r\n    _this.warningUnhooked();\r\n    var prevStore = _this.store;\r\n    var namePathList = [];\r\n    fields.forEach(function (fieldData) {\r\n      var name = fieldData.name,\r\n        data = _objectWithoutProperties(fieldData, _excluded);\r\n      var namePath = getNamePath(name);\r\n      namePathList.push(namePath);\r\n      // Value\r\n      if ('value' in data) {\r\n        _this.updateStore(setValue(_this.store, namePath, data.value));\r\n      }\r\n      _this.notifyObservers(prevStore, [namePath], {\r\n        type: 'setField',\r\n        data: fieldData\r\n      });\r\n    });\r\n    _this.notifyWatch(namePathList);\r\n  };\r\n  this.getFields = function () {\r\n    var entities = _this.getFieldEntities(true);\r\n    var fields = entities.map(function (field) {\r\n      var namePath = field.getNamePath();\r\n      var meta = field.getMeta();\r\n      var fieldData = _objectSpread(_objectSpread({}, meta), {}, {\r\n        name: namePath,\r\n        value: _this.getFieldValue(namePath)\r\n      });\r\n      Object.defineProperty(fieldData, 'originRCField', {\r\n        value: true\r\n      });\r\n      return fieldData;\r\n    });\r\n    return fields;\r\n  };\r\n  // =========================== Observer ===========================\r\n  /**\r\n   * This only trigger when a field is on constructor to avoid we get initialValue too late\r\n   */\r\n  this.initEntityValue = function (entity) {\r\n    var initialValue = entity.props.initialValue;\r\n    if (initialValue !== undefined) {\r\n      var namePath = entity.getNamePath();\r\n      var prevValue = getValue(_this.store, namePath);\r\n      if (prevValue === undefined) {\r\n        _this.updateStore(setValue(_this.store, namePath, initialValue));\r\n      }\r\n    }\r\n  };\r\n  this.isMergedPreserve = function (fieldPreserve) {\r\n    var mergedPreserve = fieldPreserve !== undefined ? fieldPreserve : _this.preserve;\r\n    return mergedPreserve !== null && mergedPreserve !== void 0 ? mergedPreserve : true;\r\n  };\r\n  this.registerField = function (entity) {\r\n    _this.fieldEntities.push(entity);\r\n    var namePath = entity.getNamePath();\r\n    _this.notifyWatch([namePath]);\r\n    // Set initial values\r\n    if (entity.props.initialValue !== undefined) {\r\n      var prevStore = _this.store;\r\n      _this.resetWithFieldInitialValue({\r\n        entities: [entity],\r\n        skipExist: true\r\n      });\r\n      _this.notifyObservers(prevStore, [entity.getNamePath()], {\r\n        type: 'valueUpdate',\r\n        source: 'internal'\r\n      });\r\n    }\r\n    // un-register field callback\r\n    return function (isListField, preserve) {\r\n      var subNamePath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\r\n      _this.fieldEntities = _this.fieldEntities.filter(function (item) {\r\n        return item !== entity;\r\n      });\r\n      // Clean up store value if not preserve\r\n      if (!_this.isMergedPreserve(preserve) && (!isListField || subNamePath.length > 1)) {\r\n        var defaultValue = isListField ? undefined : _this.getInitialValue(namePath);\r\n        if (namePath.length && _this.getFieldValue(namePath) !== defaultValue && _this.fieldEntities.every(function (field) {\r\n          return (\r\n            // Only reset when no namePath exist\r\n            !matchNamePath(field.getNamePath(), namePath)\r\n          );\r\n        })) {\r\n          var _prevStore = _this.store;\r\n          _this.updateStore(setValue(_prevStore, namePath, defaultValue, true));\r\n          // Notify that field is unmount\r\n          _this.notifyObservers(_prevStore, [namePath], {\r\n            type: 'remove'\r\n          });\r\n          // Dependencies update\r\n          _this.triggerDependenciesUpdate(_prevStore, namePath);\r\n        }\r\n      }\r\n      _this.notifyWatch([namePath]);\r\n    };\r\n  };\r\n  this.dispatch = function (action) {\r\n    switch (action.type) {\r\n      case 'updateValue':\r\n        {\r\n          var namePath = action.namePath,\r\n            value = action.value;\r\n          _this.updateValue(namePath, value);\r\n          break;\r\n        }\r\n      case 'validateField':\r\n        {\r\n          var _namePath = action.namePath,\r\n            triggerName = action.triggerName;\r\n          _this.validateFields([_namePath], {\r\n            triggerName: triggerName\r\n          });\r\n          break;\r\n        }\r\n      default:\r\n      // Currently we don't have other action. Do nothing.\r\n    }\r\n  };\r\n  this.notifyObservers = function (prevStore, namePathList, info) {\r\n    if (_this.subscribable) {\r\n      var mergedInfo = _objectSpread(_objectSpread({}, info), {}, {\r\n        store: _this.getFieldsValue(true)\r\n      });\r\n      _this.getFieldEntities().forEach(function (_ref3) {\r\n        var onStoreChange = _ref3.onStoreChange;\r\n        onStoreChange(prevStore, namePathList, mergedInfo);\r\n      });\r\n    } else {\r\n      _this.forceRootUpdate();\r\n    }\r\n  };\r\n  /**\r\n   * Notify dependencies children with parent update\r\n   * We need delay to trigger validate in case Field is under render props\r\n   */\r\n  this.triggerDependenciesUpdate = function (prevStore, namePath) {\r\n    var childrenFields = _this.getDependencyChildrenFields(namePath);\r\n    if (childrenFields.length) {\r\n      _this.validateFields(childrenFields);\r\n    }\r\n    _this.notifyObservers(prevStore, childrenFields, {\r\n      type: 'dependenciesUpdate',\r\n      relatedFields: [namePath].concat(_toConsumableArray(childrenFields))\r\n    });\r\n    return childrenFields;\r\n  };\r\n  this.updateValue = function (name, value) {\r\n    var namePath = getNamePath(name);\r\n    var prevStore = _this.store;\r\n    _this.updateStore(setValue(_this.store, namePath, value));\r\n    _this.notifyObservers(prevStore, [namePath], {\r\n      type: 'valueUpdate',\r\n      source: 'internal'\r\n    });\r\n    _this.notifyWatch([namePath]);\r\n    // Dependencies update\r\n    var childrenFields = _this.triggerDependenciesUpdate(prevStore, namePath);\r\n    // trigger callback function\r\n    var onValuesChange = _this.callbacks.onValuesChange;\r\n    if (onValuesChange) {\r\n      var changedValues = cloneByNamePathList(_this.store, [namePath]);\r\n      onValuesChange(changedValues, _this.getFieldsValue());\r\n    }\r\n    _this.triggerOnFieldsChange([namePath].concat(_toConsumableArray(childrenFields)));\r\n  };\r\n  // Let all child Field get update.\r\n  this.setFieldsValue = function (store) {\r\n    _this.warningUnhooked();\r\n    var prevStore = _this.store;\r\n    if (store) {\r\n      var nextStore = merge(_this.store, store);\r\n      _this.updateStore(nextStore);\r\n    }\r\n    _this.notifyObservers(prevStore, null, {\r\n      type: 'valueUpdate',\r\n      source: 'external'\r\n    });\r\n    _this.notifyWatch();\r\n  };\r\n  this.setFieldValue = function (name, value) {\r\n    _this.setFields([{\r\n      name: name,\r\n      value: value\r\n    }]);\r\n  };\r\n  this.getDependencyChildrenFields = function (rootNamePath) {\r\n    var children = new Set();\r\n    var childrenFields = [];\r\n    var dependencies2fields = new NameMap();\r\n    /**\r\n     * Generate maps\r\n     * Can use cache to save perf if user report performance issue with this\r\n     */\r\n    _this.getFieldEntities().forEach(function (field) {\r\n      var dependencies = field.props.dependencies;\r\n      (dependencies || []).forEach(function (dependency) {\r\n        var dependencyNamePath = getNamePath(dependency);\r\n        dependencies2fields.update(dependencyNamePath, function () {\r\n          var fields = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Set();\r\n          fields.add(field);\r\n          return fields;\r\n        });\r\n      });\r\n    });\r\n    var fillChildren = function fillChildren(namePath) {\r\n      var fields = dependencies2fields.get(namePath) || new Set();\r\n      fields.forEach(function (field) {\r\n        if (!children.has(field)) {\r\n          children.add(field);\r\n          var fieldNamePath = field.getNamePath();\r\n          if (field.isFieldDirty() && fieldNamePath.length) {\r\n            childrenFields.push(fieldNamePath);\r\n            fillChildren(fieldNamePath);\r\n          }\r\n        }\r\n      });\r\n    };\r\n    fillChildren(rootNamePath);\r\n    return childrenFields;\r\n  };\r\n  this.triggerOnFieldsChange = function (namePathList, filedErrors) {\r\n    var onFieldsChange = _this.callbacks.onFieldsChange;\r\n    if (onFieldsChange) {\r\n      var fields = _this.getFields();\r\n      /**\r\n       * Fill errors since `fields` may be replaced by controlled fields\r\n       */\r\n      if (filedErrors) {\r\n        var cache = new NameMap();\r\n        filedErrors.forEach(function (_ref4) {\r\n          var name = _ref4.name,\r\n            errors = _ref4.errors;\r\n          cache.set(name, errors);\r\n        });\r\n        fields.forEach(function (field) {\r\n          // eslint-disable-next-line no-param-reassign\r\n          field.errors = cache.get(field.name) || field.errors;\r\n        });\r\n      }\r\n      var changedFields = fields.filter(function (_ref5) {\r\n        var fieldName = _ref5.name;\r\n        return containsNamePath(namePathList, fieldName);\r\n      });\r\n      if (changedFields.length) {\r\n        onFieldsChange(changedFields, fields);\r\n      }\r\n    }\r\n  };\r\n  // =========================== Validate ===========================\r\n  this.validateFields = function (arg1, arg2) {\r\n    _this.warningUnhooked();\r\n    var nameList;\r\n    var options;\r\n    if (Array.isArray(arg1) || typeof arg1 === 'string' || typeof arg2 === 'string') {\r\n      nameList = arg1;\r\n      options = arg2;\r\n    } else {\r\n      options = arg1;\r\n    }\r\n    var provideNameList = !!nameList;\r\n    var namePathList = provideNameList ? nameList.map(getNamePath) : [];\r\n    // Collect result in promise list\r\n    var promiseList = [];\r\n    // We temp save the path which need trigger for `onFieldsChange`\r\n    var TMP_SPLIT = String(Date.now());\r\n    var validateNamePathList = new Set();\r\n    _this.getFieldEntities(true).forEach(function (field) {\r\n      var _options;\r\n      // Add field if not provide `nameList`\r\n      if (!provideNameList) {\r\n        namePathList.push(field.getNamePath());\r\n      }\r\n      /**\r\n       * Recursive validate if configured.\r\n       * TODO: perf improvement @zombieJ\r\n       */\r\n      if (((_options = options) === null || _options === void 0 ? void 0 : _options.recursive) && provideNameList) {\r\n        var namePath = field.getNamePath();\r\n        if (\r\n        // nameList[i] === undefined 说明是以 nameList 开头的\r\n        // ['name'] -> ['name','list']\r\n        namePath.every(function (nameUnit, i) {\r\n          return nameList[i] === nameUnit || nameList[i] === undefined;\r\n        })) {\r\n          namePathList.push(namePath);\r\n        }\r\n      }\r\n      // Skip if without rule\r\n      if (!field.props.rules || !field.props.rules.length) {\r\n        return;\r\n      }\r\n      var fieldNamePath = field.getNamePath();\r\n      validateNamePathList.add(fieldNamePath.join(TMP_SPLIT));\r\n      // Add field validate rule in to promise list\r\n      if (!provideNameList || containsNamePath(namePathList, fieldNamePath)) {\r\n        var promise = field.validateRules(_objectSpread({\r\n          validateMessages: _objectSpread(_objectSpread({}, defaultValidateMessages), _this.validateMessages)\r\n        }, options));\r\n        // Wrap promise with field\r\n        promiseList.push(promise.then(function () {\r\n          return {\r\n            name: fieldNamePath,\r\n            errors: [],\r\n            warnings: []\r\n          };\r\n        }).catch(function (ruleErrors) {\r\n          var _ruleErrors$forEach;\r\n          var mergedErrors = [];\r\n          var mergedWarnings = [];\r\n          (_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 ? void 0 : _ruleErrors$forEach.call(ruleErrors, function (_ref6) {\r\n            var warningOnly = _ref6.rule.warningOnly,\r\n              errors = _ref6.errors;\r\n            if (warningOnly) {\r\n              mergedWarnings.push.apply(mergedWarnings, _toConsumableArray(errors));\r\n            } else {\r\n              mergedErrors.push.apply(mergedErrors, _toConsumableArray(errors));\r\n            }\r\n          });\r\n          if (mergedErrors.length) {\r\n            return Promise.reject({\r\n              name: fieldNamePath,\r\n              errors: mergedErrors,\r\n              warnings: mergedWarnings\r\n            });\r\n          }\r\n          return {\r\n            name: fieldNamePath,\r\n            errors: mergedErrors,\r\n            warnings: mergedWarnings\r\n          };\r\n        }));\r\n      }\r\n    });\r\n    var summaryPromise = allPromiseFinish(promiseList);\r\n    _this.lastValidatePromise = summaryPromise;\r\n    // Notify fields with rule that validate has finished and need update\r\n    summaryPromise.catch(function (results) {\r\n      return results;\r\n    }).then(function (results) {\r\n      var resultNamePathList = results.map(function (_ref7) {\r\n        var name = _ref7.name;\r\n        return name;\r\n      });\r\n      _this.notifyObservers(_this.store, resultNamePathList, {\r\n        type: 'validateFinish'\r\n      });\r\n      _this.triggerOnFieldsChange(resultNamePathList, results);\r\n    });\r\n    var returnPromise = summaryPromise.then(function () {\r\n      if (_this.lastValidatePromise === summaryPromise) {\r\n        return Promise.resolve(_this.getFieldsValue(namePathList));\r\n      }\r\n      return Promise.reject([]);\r\n    }).catch(function (results) {\r\n      var errorList = results.filter(function (result) {\r\n        return result && result.errors.length;\r\n      });\r\n      return Promise.reject({\r\n        values: _this.getFieldsValue(namePathList),\r\n        errorFields: errorList,\r\n        outOfDate: _this.lastValidatePromise !== summaryPromise\r\n      });\r\n    });\r\n    // Do not throw in console\r\n    returnPromise.catch(function (e) {\r\n      return e;\r\n    });\r\n    // `validating` changed. Trigger `onFieldsChange`\r\n    var triggerNamePathList = namePathList.filter(function (namePath) {\r\n      return validateNamePathList.has(namePath.join(TMP_SPLIT));\r\n    });\r\n    _this.triggerOnFieldsChange(triggerNamePathList);\r\n    return returnPromise;\r\n  };\r\n  // ============================ Submit ============================\r\n  this.submit = function () {\r\n    _this.warningUnhooked();\r\n    _this.validateFields().then(function (values) {\r\n      var onFinish = _this.callbacks.onFinish;\r\n      if (onFinish) {\r\n        try {\r\n          onFinish(values);\r\n        } catch (err) {\r\n          // Should print error if user `onFinish` callback failed\r\n          console.error(err);\r\n        }\r\n      }\r\n    }).catch(function (e) {\r\n      var onFinishFailed = _this.callbacks.onFinishFailed;\r\n      if (onFinishFailed) {\r\n        onFinishFailed(e);\r\n      }\r\n    });\r\n  };\r\n  this.forceRootUpdate = forceRootUpdate;\r\n});\r\nfunction useForm(form) {\r\n  var formRef = React.useRef();\r\n  var _React$useState = React.useState({}),\r\n    _React$useState2 = _slicedToArray(_React$useState, 2),\r\n    forceUpdate = _React$useState2[1];\r\n  if (!formRef.current) {\r\n    if (form) {\r\n      formRef.current = form;\r\n    } else {\r\n      // Create a new FormStore if not provided\r\n      var forceReRender = function forceReRender() {\r\n        forceUpdate({});\r\n      };\r\n      var formStore = new FormStore(forceReRender);\r\n      formRef.current = formStore.getForm();\r\n    }\r\n  }\r\n  return [formRef.current];\r\n}\r\nexport default useForm;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}